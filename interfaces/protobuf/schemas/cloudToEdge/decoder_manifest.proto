/*
 * Copyright 2020 Amazon.com, Inc. and its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0
 * Licensed under the Amazon Software License (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * http://aws.amazon.com/asl/
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

syntax = "proto3";

option java_package = "com.amazonaws.iot.autobahn.schemas";
package Aws.IoTFleetWise.Schemas.DecoderManifestMsg;

message DecoderManifest {

  /*
   * Amazon Resource Name and version of the decoder manifest
   */
  string arn = 1;

  /*
   * List of signals that are sent and received on the CAN BUS in the vehicle
   */
  repeated CANSignal can_signals = 2;

  /*
   * List of OBDII-PID signals and corresponding decoding rules
   */
  repeated OBDPIDSignal obd_pid_signals = 3;
}

message CANSignal {

  /*
   * Unique integer identifier of the signal generated by Cloud Designer
   */
  uint32 signal_id = 1;

  /*
   * Interface ID for CAN network interface this signal is found on. The CAN network interface details are provided as
   * a part of the edge static configuration file.
   */
  string interface_id = 2;

  /*
   * CAN Message Id
   */
  uint32 message_id = 3;

  /*
   * True when signal is encoded in Big Endian
   */
  bool is_big_endian = 4;

  /*
   * True when signal is signed
   */
  bool is_signed = 5;

  /*
   * Start bit position of the signal in the message
   */
  uint32 start_bit = 6;

  /*
   * physical_signal_value = raw_value * factor + offset
   */
  double offset = 7;

  /*
   * physical_signal_value = raw_value * factor + offset
   */
  double factor = 8;

  /*
   * Length of the CAN signal
   */
  uint32 length = 9;
}

/*
 * This is the OBDII-PID signal decoding rule. One OBDII-PID could contain multiple signals. Below section is the
 * decoder rule per signal, not per PID
 */
message OBDPIDSignal {

  /*
   * Unique numeric identifier for the OBDII-PID signal
   */
  uint32 signal_id = 1;

  /*
   * Interface ID for CAN network interface this signal is found on. The CAN network interface details are provided as
   * a part of the edge static configuration file.
   */
  string interface_id = 2;

  /*
   * Length of the PID response. Note this is not the signal byte length as PID might contain multiple signals
   */
  uint32 pid_response_length = 3;

  /*
   * OBDII-PID Service Mode for the signal in decimal
   */
  uint32 service_mode = 4;

  /*
   * OBD request PID in decimal
   */
  uint32 pid = 5;

  /*
   * scaling to decode OBD from raw bytes to double value
   * e.g. A * 0.0125 - 40. Scaling is 0.0125
   */
  double scaling = 6;

  /*
   * offset to decode OBD from raw bytes to double value
   * e.g. A * 0.0125 - 40. offset is -40.0
   */
  double offset = 7;

  /*
   * the start byte order (starting from 0th) for this signal in its PID query response 
   * e.g. PID 0x14 contains two signals, with Signal B located in the 2nd byte startByte is 1
   */
  uint32 start_byte = 8;

  /*
   * number of bytes for this signal in its PID query response
   * e.g. PID 0x14 contains two signals. SHRFT is one byte. Its byteLength is 1
   */
  uint32 byte_length = 9;

  /*
   * Right shift on bits to decode this signal from raw bytes. Note the bit manipulation is only performed when
   * byteLength is 1. e.g. Boost Pressure B Control Status is bit 2, 3 on byte J. The right shift shall be 2 For
   * non-bitmask signals, the right shift shall always be 0
   */
  uint32 bit_right_shift = 10;

  /*
   * bit Mask Length to be applied to decode this signal from raw byte. Note the bit manipulation is only performed when
   * byteLength is 1. e.g. Boost Pressure B Control Status is bit 2, 3 on byte J. The bit Mask Length would be 2 For
   * non-bitmask signals, the bit Mask Length shall always be 8.
   */
  uint32 bit_mask_length = 11;
}
