# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

# This generates protobuf library for proto files in another package
# Consumers need only declare the libraryAliasName in their target_link_libraries

find_package(Protobuf REQUIRED)

set(CMAKE_CXX_CLANG_TIDY "")

# These are the library names and aliases
set(libraryTargetName iotfleetwise.proto)
set(libraryAliasName IoTFleetWise::Proto)


# This directory will contain proto files and autogenerated source and headers
set(protoDir ${CMAKE_BINARY_DIR}/proto/)

set(schemasRoot "${CMAKE_CURRENT_SOURCE_DIR}/interfaces/protobuf")
message(STATUS "Schema root is: ${schemasRoot}")

# Make a list of all the proto files
file(GLOB_RECURSE protoFilesExternal FOLLOW_SYMLINKS ${schemasRoot}/*.proto)

# Copy the proto files to a proto directory in the build tree. Do this because
# the file paths we have are symlinked file paths and can't easily be made
# relative to build path for the protoc to work.
# These will be symlinks
file(COPY ${protoFilesExternal} DESTINATION ${protoDir})

foreach(protoFileName ${protoFilesExternal})
  get_filename_component(protoFile ${protoFileName} NAME)

  message(STATUS "File name of proto is: ${protoFile}")

  if(protoFile)
    message(STATUS "Protobuf file found.")
  else()
    message(FATAL_ERROR "Protobuf file not found.")
  endif()

  # Replace .proto -> .pb.cc
  string(REGEX REPLACE "[.]proto$" ".pb.cc" outputSource ${protoFile})
  string(PREPEND outputSource ${protoDir})
  # Replace .proto -> .pb.h
  string(REGEX REPLACE "[.]proto$" ".pb.h" outputHeader ${protoFile})
  string(PREPEND outputHeader ${protoDir})

  # At this point we have a list of headers and source files with a full paths
  add_custom_command(
    DEPENDS ${protoFileName}
    OUTPUT ${outputSource} ${outputHeader}
    COMMAND protoc -I=${protoDir} --cpp_out=${protoDir} ${protoFile}
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
    COMMENT "Generating protobuf source for ${protoFile}"
  )

  message(STATUS "Output source: ${outputSource}")
  message(STATUS "Output header: ${outputHeader}")

  list(APPEND outputSourcesList ${outputSource})
  list(APPEND outputHeadersList ${outputHeader})
endforeach()

# Ignore warnings due to this issue https://github.com/protocolbuffers/protobuf/pull/7913
# Fixed in protobuf v3.15.5
set_source_files_properties(${outputSourcesList} PROPERTIES COMPILE_FLAGS -Wno-array-bounds)


# create a target that includes some_file, this gives us a name that we can use later
add_custom_target(protoGenTarget DEPENDS ${outputSourcesList} ${outputHeadersList})

add_library(
  ${libraryTargetName}
  ${outputSourcesList}
)

# This links the protobuf library we are creating with
add_dependencies(${libraryTargetName} protoGenTarget)

target_link_libraries(
  ${libraryTargetName}
  PUBLIC
  protobuf::libprotobuf
)

target_include_directories(
  ${libraryTargetName}
  PUBLIC
  ${protoDir}
)

# Export the alias library that will be consumed by dependencies
add_library(${libraryAliasName} ALIAS ${libraryTargetName})
